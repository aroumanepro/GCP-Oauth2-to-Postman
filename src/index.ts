import { app, BrowserWindow, ipcMain, Menu } from "electron";
import { exec, spawn } from "child_process";
import express from "express";
import path from "path";
import fs from "fs";
import { actionAuth, auth, token } from "./server/processors/auth.processors";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

let server: any;
const port = 8086;
const expressApp = express();

expressApp.use(express.json());

// Configuration du moteur de template EJS
expressApp.set("view engine", "ejs");
expressApp.set("views", path.join(process.cwd(), "src", "server", "views"));

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 600,
    width: 900,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // and load the index.html of the app.
  console.log("test", MAIN_WINDOW_WEBPACK_ENTRY);
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  //mainWindow.webContents.openDevTools();
  // Désactiver le menu
  Menu.setApplicationMenu(null);
};

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

/*app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});*/

const runGcloudCommand = (command: string): Promise<string> => {
  return new Promise((resolve, reject) => {
    exec(command, (error, stdout, stderr) => {
      if (error) {
        reject(`error: ${error.message}`);
        return;
      }
      if (stderr) {
        reject(`stderr: ${stderr}`);
        return;
      }
      resolve(stdout);
    });
  });
};

const runGcloudAuth = (): Promise<string> => {
  return new Promise((resolve, reject) => {
    const process = spawn("gcloud", ["auth", "login"]);

    process.stdout.on("data", (data) => {
      const output = data.toString();
      console.log(output);
      if (output.includes("You are now logged in as")) {
        resolve(output);
      }
    });

    process.stderr.on("data", (data) => {
      console.error(data.toString());
      reject(new Error(data.toString()));
    });

    process.on("error", (error) => {
      console.error("Error during gcloud auth login:", error);
      reject(error);
    });

    process.on("close", (code) => {
      if (code !== 0) {
        reject(new Error(`gcloud auth login process exited with code ${code}`));
      }
    });
  });
};

const runGcloudAuthDefaultApp = (): Promise<string> => {
  return new Promise((resolve, reject) => {
    const process = spawn("sh", [
      "-c",
      "unset GOOGLE_APPLICATION_CREDENTIALS && gcloud auth application-default login",
    ]);

    process.stdout.on("data", (data) => {
      const output = data.toString();
      console.log(output);
      if (output.includes("You are now logged in as")) {
        resolve(output);
      }
    });

    process.stderr.on("data", (data) => {
      console.error(data.toString());
      reject(new Error(data.toString()));
    });

    process.on("error", (error) => {
      console.error("Error during gcloud auth login:", error);
      reject(error);
    });

    process.on("close", (code) => {
      if (code !== 0) {
        reject(new Error(`gcloud auth login process exited with code ${code}`));
      }
    });
  });
};

export const checkGcloudAuthDefaultApp = (): Promise<boolean> => {
  return new Promise((resolve, reject) => {
    const credentialsPath = path.join(
      process.env.HOME,
      ".config/gcloud/application_default_credentials.json"
    );

    // Vérifier si le fichier de credentials existe
    if (fs.existsSync(credentialsPath)) {
      resolve(true);
    } else {
      console.error(
        "Google Application Default credentials file does not exist."
      );
      resolve(false);
    }
  });
};

export const revokeGcloudAuthDefaultApp = (): Promise<boolean> => {
  return new Promise((resolve, reject) => {
    const process = spawn("gcloud", [
      "auth",
      "application-default",
      "revoke",
      "--quiet",
    ]);

    process.stdout.on("data", (data) => {
      const output = data.toString();
      if (output.includes("Credentials revoked")) {
        resolve(true);
      } else {
        resolve(false);
      }
    });

    process.stderr.on("data", (data) => {
      console.error(data.toString());
      reject(new Error(data.toString()));
    });

    process.on("error", (error) => {
      console.error("Error during gcloud auth list:", error);
      reject(error);
    });

    process.on("close", (code) => {
      if (code !== 0) {
        reject(new Error(`gcloud auth list process exited with code ${code}`));
      }
    });
  });
};

export const checkGcloudAuth = (): Promise<boolean> => {
  return new Promise((resolve, reject) => {
    const process = spawn("gcloud", ["auth", "list"]);

    process.stdout.on("data", (data) => {
      const output = data.toString();
      if (output.includes("ACTIVE")) {
        resolve(true);
      } else {
        resolve(false);
      }
    });

    process.stderr.on("data", (data) => {
      console.error(data.toString());
      reject(false);
    });

    process.on("error", (error) => {
      console.error("Error during gcloud auth list:", error);
      reject(error);
    });

    process.on("close", (code) => {
      if (code !== 0) {
        reject(new Error(`gcloud auth list process exited with code ${code}`));
      }
    });
  });
};

export const revokeGcloudAuth = (): Promise<boolean> => {
  return new Promise((resolve, reject) => {
    const process = spawn("gcloud", ["auth", "revoke", "--all"]);

    process.stdout.on("data", (data) => {
      const output = data.toString();
      if (output.includes("ACTIVE")) {
        resolve(true);
      } else {
        resolve(false);
      }
    });

    process.stderr.on("data", (data) => {
      console.error(data.toString());
      reject(new Error(data.toString()));
    });

    process.on("error", (error) => {
      console.error("Error during gcloud auth list:", error);
      reject(error);
    });

    process.on("close", (code) => {
      if (code !== 0) {
        reject(new Error(`gcloud auth list process exited with code ${code}`));
      }
    });
  });
};

const startServer = () => {
  server = expressApp.listen(port, () => {
    console.log(`Server is running on http://localhost:${port}`);
    sendLog(`Server is running on http://localhost:${port}`);
  });
};

const stopServer = () => {
  if (server) {
    server.close(() => {
      console.log("Server stopped.");
      sendLog("Server stopped.");
      server = null; // Réinitialiser la variable server
    });
  } else {
    console.log("Server is not running.");
    sendLog("Server is not running.");
  }

  // Utiliser netstat pour trouver et tuer le processus écoutant sur le port
  const command = `netstat -tuln | grep :${port} || true`;
  exec(command, (err, stdout, stderr) => {
    if (err && !stdout) {
      console.error(`Error checking port ${port}:`, err);
      return;
    }

    const lines = stdout.trim().split("\n");
    if (lines.length > 0) {
      lines.forEach((line) => {
        const parts = line.trim().split(/\s+/);
        if (parts.length > 6) {
          const pid = parts[6].split("/")[0];
          console.log(`Killing process ${pid} on port ${port}`);
          exec(`kill -9 ${pid}`, (err, stdout, stderr) => {
            if (err || stderr) {
              console.error(`Error killing process ${pid}:`, err || stderr);
            } else {
              console.log(`Process ${pid} killed.`);
            }
          });
        }
      });
    }
  });
};

const sendLog = (message: string) => {
  const windows = BrowserWindow.getAllWindows();
  if (windows.length > 0) {
    windows[0].webContents.send("log", message);
  }
};


expressApp.get("/auth2/auth/gcp", (req, res) => {
  return auth(req, res);
});

expressApp.post("/token", (req, res) => {
  return token(req, res);
});

app.whenReady().then(() => {
  createWindow();

  ipcMain.on("start-server", () => {
    startServer();
    BrowserWindow.getAllWindows()[0].webContents.send(
      "server-status",
      "started"
    );
  });

  ipcMain.on("stop-server", () => {
    stopServer();
    BrowserWindow.getAllWindows()[0].webContents.send(
      "server-status",
      "stopped"
    );
  });

  ipcMain.handle("run-gcloud-command", async (_event, command) => {
    try {
      const result = await runGcloudCommand(command);
      return result;
    } catch (error) {
      return error.message;
    }
  });

  ipcMain.handle("run-gcloud-auth", async () => {
    try {
      const result = await runGcloudAuth();
      return result;
    } catch (error) {
      return error.message;
    }
  });

  ipcMain.handle("run-gcloud-auth-default-app", async () => {
    try {
      const result = await runGcloudAuthDefaultApp();
      return result;
    } catch (error) {
      return error.message;
    }
  });

  ipcMain.handle("check-gcloud-auth", async () => {
    try {
      const result = await checkGcloudAuth();
      console.log(result);
      return result;
    } catch (error) {
      return error.message;
    }
  });

  ipcMain.handle("check-gcloud-auth-default-app", async () => {
    try {
      const result = await checkGcloudAuthDefaultApp();
      console.log(result);
      return result;
    } catch (error) {
      return error.message;
    }
  });

  ipcMain.handle("revoke-gcloud-auth", async () => {
    try {
      const result = await revokeGcloudAuth();
      console.log(result);
      return result;
    } catch (error) {
      return error.message;
    }
  });

  ipcMain.handle("revoke-gcloud-auth-default-app", async () => {
    try {
      const result = await revokeGcloudAuthDefaultApp();
      console.log(result);
      return result;
    } catch (error) {
      return error.message;
    }
  });

  ipcMain.handle("get-server-status", async () => {
    const status = server ? true : false;
    return status;
  });

  app.on("activate", () => {
    if (BrowserWindow.getAllWindows().length === 0) createWindow();
  });
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
